<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Cade: cade.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cade</div>
   <div id="projectbrief">A cycle-accurate DCPU-16 emulator, written in C.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cade.c File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="cade_8h_source.html">cade.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThunk.html">Thunk</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapped function pointer.  <a href="structThunk.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDCPU__State.html">DCPU_State</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal representation of the state of the emulated DCPU-16.  <a href="structDCPU__State.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dcf8c45f945dd0c4301a94700f2112c"></a><!-- doxytag: member="cade.c::MEM_SIZE" ref="a2dcf8c45f945dd0c4301a94700f2112c" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#a2dcf8c45f945dd0c4301a94700f2112c">MEM_SIZE</a>&#160;&#160;&#160;0x10000</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the emulated DCPU-16's memory. <br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc2e88157b600355f34859fbb8d1da61"></a><!-- doxytag: member="cade.c::Thunk" ref="afc2e88157b600355f34859fbb8d1da61" args="" -->
typedef struct <a class="el" href="structThunk.html">Thunk</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Thunk</b></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#a524b8dccee3d5689caaf791e08580dee">DCPU_BasicOp</a> { <br/>
&#160;&#160;<b>OP_NOBASIC</b> =  0, 
<b>OP_SET</b>, 
<b>OP_ADD</b>, 
<b>OP_SUB</b>, 
<br/>
&#160;&#160;<b>OP_MUL</b>, 
<b>OP_DIV</b>, 
<b>OP_MOD</b>, 
<b>OP_SHL</b>, 
<br/>
&#160;&#160;<b>OP_SHR</b>, 
<b>OP_AND</b>, 
<b>OP_BOR</b>, 
<b>OP_XOR</b>, 
<br/>
&#160;&#160;<b>OP_IFE</b>, 
<b>OP_IFN</b>, 
<b>OP_IFG</b>, 
<b>OP_IFB</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The basic opcodes for the processor.  <a href="cade_8c.html#a524b8dccee3d5689caaf791e08580dee">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#a174b6ab34aad87534732a874eb68c519">DCPU_ExtendedOp</a> { <b>XOP_JSR</b> =  1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The extended opcodes for the processor.  <a href="cade_8c.html#a174b6ab34aad87534732a874eb68c519">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#aa017403c538b5577da073291de0d0435">DCPU_Value</a> { <br/>
&#160;&#160;<b>VAL_REG_A</b> =  0, 
<b>VAL_REG_B</b>, 
<b>VAL_REG_C</b>, 
<b>VAL_REG_X</b>, 
<br/>
&#160;&#160;<b>VAL_REG_Y</b>, 
<b>VAL_REG_Z</b>, 
<b>VAL_REG_I</b>, 
<b>VAL_REG_J</b>, 
<br/>
&#160;&#160;<b>VAL_DEREF_REG_A</b>, 
<b>VAL_DEREF_REG_B</b>, 
<b>VAL_DEREF_REG_C</b>, 
<b>VAL_DEREF_REG_X</b>, 
<br/>
&#160;&#160;<b>VAL_DEREF_REG_Y</b>, 
<b>VAL_DEREF_REG_Z</b>, 
<b>VAL_DEREF_REG_I</b>, 
<b>VAL_DEREF_REG_J</b>, 
<br/>
&#160;&#160;<b>VAL_SUCC_REG_A</b>, 
<b>VAL_SUCC_REG_B</b>, 
<b>VAL_SUCC_REG_C</b>, 
<b>VAL_SUCC_REG_X</b>, 
<br/>
&#160;&#160;<b>VAL_SUCC_REG_Y</b>, 
<b>VAL_SUCC_REG_Z</b>, 
<b>VAL_SUCC_REG_I</b>, 
<b>VAL_SUCC_REG_J</b>, 
<br/>
&#160;&#160;<b>VAL_POP</b>, 
<b>VAL_PEEK</b>, 
<b>VAL_PUSH</b>, 
<b>VAL_SP</b>, 
<br/>
&#160;&#160;<b>VAL_PC</b>, 
<b>VAL_O</b>, 
<b>VAL_SUCC</b>, 
<b>VAL_SUCC_LIT</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the various value types, this is what is generally encoded in instructions where values are needed. The literal range is excluded. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#aa0e7badb5071f22a3ee11e625bea680b">DCPU_GetRegisterName</a> (<a class="el" href="cade_8h.html#a7c64f3936922fde21f3f804260bf73a3">DCPU_Register</a> reg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing the name of the indicated register.  <a href="#aa0e7badb5071f22a3ee11e625bea680b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad34eaaa703cdfb81501c85751de21e2c"></a><!-- doxytag: member="cade.c::DCPU_InstructionLength" ref="ad34eaaa703cdfb81501c85751de21e2c" args="(uint16_t inst)" -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#ad34eaaa703cdfb81501c85751de21e2c">DCPU_InstructionLength</a> (uint16_t inst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns length of the given instruction, in words. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#a3489ed4263a2524369bbff1ce64eecaf">DCPU_Create</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new DCPU-16 instance.  <a href="#a3489ed4263a2524369bbff1ce64eecaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a799eafe905b6e7436b470ce404cf1d97"></a><!-- doxytag: member="cade.c::DCPU_Destroy" ref="a799eafe905b6e7436b470ce404cf1d97" args="(DCPU_State *cpu)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#a799eafe905b6e7436b470ce404cf1d97">DCPU_Destroy</a> (<a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a DCPU-16 instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#a0b9510b64d76d68e0c408c68fbefc25a">DCPU_Init</a> (<a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes (resets) the state of an emulated DCPU-16 instance.  <a href="#a0b9510b64d76d68e0c408c68fbefc25a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#aaa5d197948df59d2e56aff49e3a44a1a">DCPU_Load</a> (<a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu, uint16_t address, const uint16_t *data, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads some data into the emulated DPCU-16's memory.  <a href="#aaa5d197948df59d2e56aff49e3a44a1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#a63c0fc1ea742d38e8a3202854acbac61">DCPU_PrintState</a> (const <a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the state of the emulated DCPU-16 instance.  <a href="#a63c0fc1ea742d38e8a3202854acbac61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#aae29e29510d7786fa2470878fd5c0acd">DCPU_Dump</a> (const <a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu, uint16_t start, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Very primitive memory-dumping.  <a href="#aae29e29510d7786fa2470878fd5c0acd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#a0d5bfbe782cd3ecfa32aee076c333ddb">DCPU_GetRegister</a> (const <a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu, <a class="el" href="cade_8h.html#a7c64f3936922fde21f3f804260bf73a3">DCPU_Register</a> reg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read out the current value of a CPU register.  <a href="#a0d5bfbe782cd3ecfa32aee076c333ddb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#a5b3ab2553aed7146bffb13264fd040f4">DCPU_GetPC</a> (const <a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read out the current value of the program counter (<code>PC</code>).  <a href="#a5b3ab2553aed7146bffb13264fd040f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#aca0f59fa6aa9d6fca73e71b3cc82dadc">DCPU_GetSP</a> (const <a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read out the current value of the stack pointer (<code>SP</code>).  <a href="#aca0f59fa6aa9d6fca73e71b3cc82dadc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#af3eb2b5718db96eb569dd822d245b1a8">DCPU_GetO</a> (const <a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read out the current value of the overflow register (<code>O</code>).  <a href="#af3eb2b5718db96eb569dd822d245b1a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#aea14396d5ee7dee57543d8e3beadd07c">DCPU_GetMemory</a> (const <a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu, uint16_t address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read out the current contents of a word of memory.  <a href="#aea14396d5ee7dee57543d8e3beadd07c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#ad3eaeb3141afd0954d988a3fc4f2f1d7">DCPU_StepCycles</a> (<a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu, size_t num_cycles)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a fixed number of instructions.  <a href="#ad3eaeb3141afd0954d988a3fc4f2f1d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#ae1b6b89cffa7257df32ba204b58a655e">DCPU_StepInstruction</a> (<a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a single whole instruction.  <a href="#ae1b6b89cffa7257df32ba204b58a655e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cade_8c.html#aadeff3717a4773da9bba5efdcca6422b">DCPU_StepUntilStuck</a> (<a class="el" href="structDCPU__State.html">DCPU_State</a> *cpu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute until the CPU seems "stuck".  <a href="#aadeff3717a4773da9bba5efdcca6422b"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"></div><hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a524b8dccee3d5689caaf791e08580dee"></a><!-- doxytag: member="cade.c::DCPU_BasicOp" ref="a524b8dccee3d5689caaf791e08580dee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cade_8c.html#a524b8dccee3d5689caaf791e08580dee">DCPU_BasicOp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The basic opcodes for the processor. </p>
<p>Basic opcodes always have two values <code>a</code> and <code>b</code>, and typically change <code>a</code>. </p>

</div>
</div>
<a class="anchor" id="a174b6ab34aad87534732a874eb68c519"></a><!-- doxytag: member="cade.c::DCPU_ExtendedOp" ref="a174b6ab34aad87534732a874eb68c519" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cade_8c.html#a174b6ab34aad87534732a874eb68c519">DCPU_ExtendedOp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The extended opcodes for the processor. </p>
<p>Extended opcodes have only one value, as opposed to two (<code>a</code> and <code>b</code>) for the basic ones. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3489ed4263a2524369bbff1ce64eecaf"></a><!-- doxytag: member="cade.c::DCPU_Create" ref="a3489ed4263a2524369bbff1ce64eecaf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDCPU__State.html">DCPU_State</a>* DCPU_Create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new DCPU-16 instance. </p>
<p>Memory is dynamically allocated to hold the emulated CPU's state; use <a class="el" href="cade_8c.html#a799eafe905b6e7436b470ce404cf1d97" title="Destroys a DCPU-16 instance.">DCPU_Destroy()</a> to free it. </p>

</div>
</div>
<a class="anchor" id="aae29e29510d7786fa2470878fd5c0acd"></a><!-- doxytag: member="cade.c::DCPU_Dump" ref="aae29e29510d7786fa2470878fd5c0acd" args="(const DCPU_State *cpu, uint16_t start, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCPU_Dump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Very primitive memory-dumping. </p>
<p>Prints contents of the emulated DCPU-16's memory in a fantastically simplistic format with one word per line.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The start address. </td></tr>
    <tr><td class="paramname">length</td><td>The number of words to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea14396d5ee7dee57543d8e3beadd07c"></a><!-- doxytag: member="cade.c::DCPU_GetMemory" ref="aea14396d5ee7dee57543d8e3beadd07c" args="(const DCPU_State *cpu, uint16_t address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t DCPU_GetMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read out the current contents of a word of memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The desired address to read out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The indicated word's contents. </dd></dl>

</div>
</div>
<a class="anchor" id="af3eb2b5718db96eb569dd822d245b1a8"></a><!-- doxytag: member="cade.c::DCPU_GetO" ref="af3eb2b5718db96eb569dd822d245b1a8" args="(const DCPU_State *cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t DCPU_GetO </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read out the current value of the overflow register (<code>O</code>). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The O register's value. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b3ab2553aed7146bffb13264fd040f4"></a><!-- doxytag: member="cade.c::DCPU_GetPC" ref="a5b3ab2553aed7146bffb13264fd040f4" args="(const DCPU_State *cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t DCPU_GetPC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read out the current value of the program counter (<code>PC</code>). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The program counter's value. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d5bfbe782cd3ecfa32aee076c333ddb"></a><!-- doxytag: member="cade.c::DCPU_GetRegister" ref="a0d5bfbe782cd3ecfa32aee076c333ddb" args="(const DCPU_State *cpu, DCPU_Register reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t DCPU_GetRegister </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cade_8h.html#a7c64f3936922fde21f3f804260bf73a3">DCPU_Register</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read out the current value of a CPU register. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The indicated register's value. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e7badb5071f22a3ee11e625bea680b"></a><!-- doxytag: member="cade.c::DCPU_GetRegisterName" ref="aa0e7badb5071f22a3ee11e625bea680b" args="(DCPU_Register reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* DCPU_GetRegisterName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cade_8h.html#a7c64f3936922fde21f3f804260bf73a3">DCPU_Register</a>&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a string containing the name of the indicated register. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A constant string (owned by Cade, should not be deallocated by caller). </dd></dl>

</div>
</div>
<a class="anchor" id="aca0f59fa6aa9d6fca73e71b3cc82dadc"></a><!-- doxytag: member="cade.c::DCPU_GetSP" ref="aca0f59fa6aa9d6fca73e71b3cc82dadc" args="(const DCPU_State *cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t DCPU_GetSP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read out the current value of the stack pointer (<code>SP</code>). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stack pointer's value. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b9510b64d76d68e0c408c68fbefc25a"></a><!-- doxytag: member="cade.c::DCPU_Init" ref="a0b9510b64d76d68e0c408c68fbefc25a" args="(DCPU_State *cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCPU_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes (resets) the state of an emulated DCPU-16 instance. </p>
<p>All memory and registers (including PC and O) are cleared to 0x0000, and the stack pointer is set to 0xffff. Any executing instruction is aborted, on the next cycle executed the DCPU-16 will fetch a new instruction to execute. </p>

</div>
</div>
<a class="anchor" id="aaa5d197948df59d2e56aff49e3a44a1a"></a><!-- doxytag: member="cade.c::DCPU_Load" ref="aaa5d197948df59d2e56aff49e3a44a1a" args="(DCPU_State *cpu, uint16_t address, const uint16_t *data, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCPU_Load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads some data into the emulated DPCU-16's memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address where the first word will be loaded. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to data to load from. </td></tr>
    <tr><td class="paramname">length</td><td>The number of words to load. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63c0fc1ea742d38e8a3202854acbac61"></a><!-- doxytag: member="cade.c::DCPU_PrintState" ref="a63c0fc1ea742d38e8a3202854acbac61" args="(const DCPU_State *cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCPU_PrintState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the state of the emulated DCPU-16 instance. </p>
<p>The contents of all registers, including the program counter, stack pointer and overflow register, are printed. </p>

</div>
</div>
<a class="anchor" id="ad3eaeb3141afd0954d988a3fc4f2f1d7"></a><!-- doxytag: member="cade.c::DCPU_StepCycles" ref="ad3eaeb3141afd0954d988a3fc4f2f1d7" args="(DCPU_State *cpu, size_t num_cycles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCPU_StepCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute a fixed number of instructions. </p>
<p>This function runs the emulated DCPU-16 for a given number of instruction cycles.</p>
<p>Note that this might leave the processor "mid-instruction".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">num_cycles</td><td>The number of clock cycles to run the processor for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1b6b89cffa7257df32ba204b58a655e"></a><!-- doxytag: member="cade.c::DCPU_StepInstruction" ref="ae1b6b89cffa7257df32ba204b58a655e" args="(DCPU_State *cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t DCPU_StepInstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute a single whole instruction. </p>
<p>This runs the emulated DCPU-16 until one instruction has been completed. If the CPU is already in the middle of executing an instruction when this is called, it will finish that instruction but not start a new.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of clock cycles spent. </dd></dl>

</div>
</div>
<a class="anchor" id="aadeff3717a4773da9bba5efdcca6422b"></a><!-- doxytag: member="cade.c::DCPU_StepUntilStuck" ref="aadeff3717a4773da9bba5efdcca6422b" args="(DCPU_State *cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t DCPU_StepUntilStuck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDCPU__State.html">DCPU_State</a> *&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute until the CPU seems "stuck". </p>
<p>Runs the emulated DCPU-16 until it appears "stuck". The DCPU-16 is considered to be stuck if executing a full instruction leaves the program counter (<code>PC</code>) register unchanged. This means the current instruction is a 1-instruction infinite loop, and since the DCPU doesn't have interrupts there's no way for it to ever exit the loop.</p>
<p>It's of course possible to come up with any number of n-instruction infinite loops that will <em>not</em> be detected by this function, so beware.</p>
<p>Note that it's possible for this to never return, since there is no guarantee that the DCPU-16 will end up in a stuck state as defined by the above.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of clock cycles spent until an infinite loop was detected. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Apr 15 2012 18:59:08 for Cade by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
